#include "../include/orderbook.hpp"
#include <chrono>

/*
ORDER METHODS
*/

// Constructor
Order::Order(OrderId orderId, Price price, Quantity quantity,
             OrderType orderType, Timestamp timestamp, TypeInForce typeInForce,
             Side side)
    : orderId(orderId), price(price), quantity(quantity), orderType(orderType),
      typeInForce(typeInForce), side(side) {

  this->timestamp =
      std::chrono::duration_cast<std::chrono::nanoseconds>(
          std::chrono::high_resolution_clock::now().time_since_epoch())
          .count();
}

/*
PRICE LEVEL METHODS
*/
std::list<Order>::iterator PriceLevel::addOrder(const Order &order) {
  orders.push_back(order);
  auto it = orders.end();
  return --it;
}

/*
ORDER BOOK METHODS
*/

SkipList<Price, PriceLevel> OrderBook::getBids() { return bids_; }

SkipList<Price, PriceLevel> OrderBook::getAsks() { return asks_; }

OrderResult OrderBook::addOrder(Order order) { // O(log P) -> O(1)
  // Validations
  if (order.quantity <= 0)
    return OrderResult::InvalidQty;

  auto it = orderLookup_.find(order.orderId);
  if (it != orderLookup_.end()) {
    return OrderResult::DuplicateOrder;
  }

  // After, we validate all the guards, we first get the price level or insert a
  // new one if it doesnt exist
  auto &book = (order.side == Side::Buy) ? bids_ : asks_;
  auto *priceLevel = book.insertOrGet(order.price); // O(log N)
  auto insertResult = priceLevel->value.addOrder(order); // O(1)

  OrderInfo entryInfo = OrderInfo{};
  entryInfo.priceLevel = &priceLevel->value;
  entryInfo.order = insertResult;

  orderLookup_.insert({order.orderId, entryInfo});

  return OrderResult::Success;
}

OrderResult OrderBook::cancelOrder(OrderId id) {
  // For cancelling, we need to make this O(1)
  // We get the order from the map, and then we can remove it from the price
  // level there

  auto it = orderLookup_.find(id);
  if (it == orderLookup_
                .end()) { // The order doesn't exist, so we return OrderNotFound
    return OrderResult::OrderNotFound;
  } else {
    // We've found the order, so we need to remove it from
    // 1. the price level within the skiplist
    // 2. the order lookup map
    // 3. the skiplist itself if the price level is empty

    auto orderPtr = it->second; // this represents the pointer to the order

    // Remove the order from the pricelevel
    // We have the memory location of the order as well as the order data
    // But, we don't have the price level pointer here, so we need to get that
    // We can get the price level pointer from the order data itself
    auto &book = (orderPtr.order->side == Side::Buy) ? bids_ : asks_;
    orderPtr.priceLevel->removeOrder(id);

    orderLookup_.erase(it);
  }

  return OrderResult::Success;
}

PriceLevel *OrderBook::bestAsk() {
  return &asks_.head_ptr->forward[0]->value;
} // O(1)

PriceLevel *OrderBook::bestBid() { return &bids_.getMax()->value; } // O(1)
